#include "cvi_venc.h"
#include "av_comp_descriptor.h"
#include "av_tpu.h"

#define PIXEL_VALUE                             (0xFF) 

static float anchors_[3][3][2] = {{{10, 13}, {16, 30}, {33, 23}},
                                  {{30, 61}, {62, 45}, {59, 119}},
                                  {{116, 90}, {156, 198}, {373, 326}}};

typedef struct {
  float x, y, w, h;
} box;

typedef struct {
  box bbox;
  int cls;
  float score;
  int batch_idx;
} detection;

static const char *coco_names[] = {
    "person",        "bicycle",       "car",           "motorbike",
    "aeroplane",     "bus",           "train",         "truck",
    "boat",          "traffic light", "fire hydrant",  "stop sign",
    "parking meter", "bench",         "bird",          "cat",
    "dog",           "horse",         "sheep",         "cow",
    "elephant",      "bear",          "zebra",         "giraffe",
    "backpack",      "umbrella",      "handbag",       "tie",
    "suitcase",      "frisbee",       "skis",          "snowboard",
    "sports ball",   "kite",          "baseball bat",  "baseball glove",
    "skateboard",    "surfboard",     "tennis racket", "bottle",
    "wine glass",    "cup",           "fork",          "knife",
    "spoon",         "bowl",          "banana",        "apple",
    "sandwich",      "orange",        "broccoli",      "carrot",
    "hot dog",       "pizza",         "donut",         "cake",
    "chair",         "sofa",          "pottedplant",   "bed",
    "diningtable",   "toilet",        "tvmonitor",     "laptop",
    "mouse",         "remote",        "keyboard",      "cell phone",
    "microwave",     "oven",          "toaster",       "sink",
    "refrigerator",  "book",          "clock",         "vase",
    "scissors",      "teddy bear",    "hair drier",    "toothbrush"};

uint8_t rasters[][13] = {
{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18},
{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x36, 0x36, 0x36},
{0x00, 0x00, 0x00, 0x66, 0x66, 0xff, 0x66, 0x66, 0xff, 0x66, 0x66, 0x00, 0x00},
{0x00, 0x00, 0x18, 0x7e, 0xff, 0x1b, 0x1f, 0x7e, 0xf8, 0xd8, 0xff, 0x7e, 0x18},
{0x00, 0x00, 0x0e, 0x1b, 0xdb, 0x6e, 0x30, 0x18, 0x0c, 0x76, 0xdb, 0xd8, 0x70},
{0x00, 0x00, 0x7f, 0xc6, 0xcf, 0xd8, 0x70, 0x70, 0xd8, 0xcc, 0xcc, 0x6c, 0x38},
{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x1c, 0x0c, 0x0e},
{0x00, 0x00, 0x0c, 0x18, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x18, 0x0c},
{0x00, 0x00, 0x30, 0x18, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x18, 0x30},
{0x00, 0x00, 0x00, 0x00, 0x99, 0x5a, 0x3c, 0xff, 0x3c, 0x5a, 0x99, 0x00, 0x00},
{0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0xff, 0xff, 0x18, 0x18, 0x18, 0x00, 0x00},
{0x00, 0x00, 0x30, 0x18, 0x1c, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0x00, 0x38, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x60, 0x60, 0x30, 0x30, 0x18, 0x18, 0x0c, 0x0c, 0x06, 0x06, 0x03, 0x03},
{0x00, 0x00, 0x3c, 0x66, 0xc3, 0xe3, 0xf3, 0xdb, 0xcf, 0xc7, 0xc3, 0x66, 0x3c},
{0x00, 0x00, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x78, 0x38, 0x18},
{0x00, 0x00, 0xff, 0xc0, 0xc0, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x03, 0xe7, 0x7e},
{0x00, 0x00, 0x7e, 0xe7, 0x03, 0x03, 0x07, 0x7e, 0x07, 0x03, 0x03, 0xe7, 0x7e},
{0x00, 0x00, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0xff, 0xcc, 0x6c, 0x3c, 0x1c, 0x0c},
{0x00, 0x00, 0x7e, 0xe7, 0x03, 0x03, 0x07, 0xfe, 0xc0, 0xc0, 0xc0, 0xc0, 0xff},
{0x00, 0x00, 0x7e, 0xe7, 0xc3, 0xc3, 0xc7, 0xfe, 0xc0, 0xc0, 0xc0, 0xe7, 0x7e},
{0x00, 0x00, 0x30, 0x30, 0x30, 0x30, 0x18, 0x0c, 0x06, 0x03, 0x03, 0x03, 0xff},
{0x00, 0x00, 0x7e, 0xe7, 0xc3, 0xc3, 0xe7, 0x7e, 0xe7, 0xc3, 0xc3, 0xe7, 0x7e},
{0x00, 0x00, 0x7e, 0xe7, 0x03, 0x03, 0x03, 0x7f, 0xe7, 0xc3, 0xc3, 0xe7, 0x7e},
{0x00, 0x00, 0x00, 0x38, 0x38, 0x00, 0x00, 0x38, 0x38, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0x30, 0x18, 0x1c, 0x1c, 0x00, 0x00, 0x1c, 0x1c, 0x00, 0x00, 0x00},
{0x00, 0x00, 0x06, 0x0c, 0x18, 0x30, 0x60, 0xc0, 0x60, 0x30, 0x18, 0x0c, 0x06},
{0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x03, 0x06, 0x0c, 0x18, 0x30, 0x60},
{0x00, 0x00, 0x18, 0x00, 0x00, 0x18, 0x18, 0x0c, 0x06, 0x03, 0xc3, 0xc3, 0x7e},
{0x00, 0x00, 0x3f, 0x60, 0xcf, 0xdb, 0xd3, 0xdd, 0xc3, 0x7e, 0x00, 0x00, 0x00},
{0x00, 0x00, 0xc3, 0xc3, 0xc3, 0xc3, 0xff, 0xc3, 0xc3, 0xc3, 0x66, 0x3c, 0x18},
{0x00, 0x00, 0xfe, 0xc7, 0xc3, 0xc3, 0xc7, 0xfe, 0xc7, 0xc3, 0xc3, 0xc7, 0xfe},
{0x00, 0x00, 0x7e, 0xe7, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xe7, 0x7e},
{0x00, 0x00, 0xfc, 0xce, 0xc7, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc7, 0xce, 0xfc},
{0x00, 0x00, 0xff, 0xc0, 0xc0, 0xc0, 0xc0, 0xfc, 0xc0, 0xc0, 0xc0, 0xc0, 0xff},
{0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xfc, 0xc0, 0xc0, 0xc0, 0xff},
{0x00, 0x00, 0x7e, 0xe7, 0xc3, 0xc3, 0xcf, 0xc0, 0xc0, 0xc0, 0xc0, 0xe7, 0x7e},
{0x00, 0x00, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xff, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3},
{0x00, 0x00, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7e},
{0x00, 0x00, 0x7c, 0xee, 0xc6, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06},
{0x00, 0x00, 0xc3, 0xc6, 0xcc, 0xd8, 0xf0, 0xe0, 0xf0, 0xd8, 0xcc, 0xc6, 0xc3},
{0x00, 0x00, 0xff, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0},
{0x00, 0x00, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xdb, 0xff, 0xff, 0xe7, 0xc3},
{0x00, 0x00, 0xc7, 0xc7, 0xcf, 0xcf, 0xdf, 0xdb, 0xfb, 0xf3, 0xf3, 0xe3, 0xe3},
{0x00, 0x00, 0x7e, 0xe7, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xe7, 0x7e},
{0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xfe, 0xc7, 0xc3, 0xc3, 0xc7, 0xfe},
{0x00, 0x00, 0x3f, 0x6e, 0xdf, 0xdb, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0x66, 0x3c},
{0x00, 0x00, 0xc3, 0xc6, 0xcc, 0xd8, 0xf0, 0xfe, 0xc7, 0xc3, 0xc3, 0xc7, 0xfe},
{0x00, 0x00, 0x7e, 0xe7, 0x03, 0x03, 0x07, 0x7e, 0xe0, 0xc0, 0xc0, 0xe7, 0x7e},
{0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xff},
{0x00, 0x00, 0x7e, 0xe7, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3},
{0x00, 0x00, 0x18, 0x3c, 0x3c, 0x66, 0x66, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3},
{0x00, 0x00, 0xc3, 0xe7, 0xff, 0xff, 0xdb, 0xdb, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3},
{0x00, 0x00, 0xc3, 0x66, 0x66, 0x3c, 0x3c, 0x18, 0x3c, 0x3c, 0x66, 0x66, 0xc3},
{0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x3c, 0x66, 0x66, 0xc3},
{0x00, 0x00, 0xff, 0xc0, 0xc0, 0x60, 0x30, 0x7e, 0x0c, 0x06, 0x03, 0x03, 0xff},
{0x00, 0x00, 0x3c, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3c},
{0x00, 0x03, 0x03, 0x06, 0x06, 0x0c, 0x0c, 0x18, 0x18, 0x30, 0x30, 0x60, 0x60},
{0x00, 0x00, 0x3c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x3c},
{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc3, 0x66, 0x3c, 0x18},
{0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x38, 0x30, 0x70},
{0x00, 0x00, 0x7f, 0xc3, 0xc3, 0x7f, 0x03, 0xc3, 0x7e, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0xfe, 0xc3, 0xc3, 0xc3, 0xc3, 0xfe, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0},
{0x00, 0x00, 0x7e, 0xc3, 0xc0, 0xc0, 0xc0, 0xc3, 0x7e, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0x7f, 0xc3, 0xc3, 0xc3, 0xc3, 0x7f, 0x03, 0x03, 0x03, 0x03, 0x03},
{0x00, 0x00, 0x7f, 0xc0, 0xc0, 0xfe, 0xc3, 0xc3, 0x7e, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0x30, 0x30, 0x30, 0x30, 0x30, 0xfc, 0x30, 0x30, 0x30, 0x33, 0x1e},
{0x7e, 0xc3, 0x03, 0x03, 0x7f, 0xc3, 0xc3, 0xc3, 0x7e, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xfe, 0xc0, 0xc0, 0xc0, 0xc0},
{0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x18, 0x00},
{0x38, 0x6c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x00, 0x00, 0x0c, 0x00},
{0x00, 0x00, 0xc6, 0xcc, 0xf8, 0xf0, 0xd8, 0xcc, 0xc6, 0xc0, 0xc0, 0xc0, 0xc0},
{0x00, 0x00, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x78},
{0x00, 0x00, 0xdb, 0xdb, 0xdb, 0xdb, 0xdb, 0xdb, 0xfe, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xfc, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00, 0x00, 0x00, 0x00},
{0xc0, 0xc0, 0xc0, 0xfe, 0xc3, 0xc3, 0xc3, 0xc3, 0xfe, 0x00, 0x00, 0x00, 0x00},
{0x03, 0x03, 0x03, 0x7f, 0xc3, 0xc3, 0xc3, 0xc3, 0x7f, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xe0, 0xfe, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0xfe, 0x03, 0x03, 0x7e, 0xc0, 0xc0, 0x7f, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0x1c, 0x36, 0x30, 0x30, 0x30, 0x30, 0xfc, 0x30, 0x30, 0x30, 0x00},
{0x00, 0x00, 0x7e, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0x18, 0x3c, 0x3c, 0x66, 0x66, 0xc3, 0xc3, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0xc3, 0xe7, 0xff, 0xdb, 0xc3, 0xc3, 0xc3, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0xc3, 0x66, 0x3c, 0x18, 0x3c, 0x66, 0xc3, 0x00, 0x00, 0x00, 0x00},
{0xc0, 0x60, 0x60, 0x30, 0x18, 0x3c, 0x66, 0x66, 0xc3, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0xff, 0x60, 0x30, 0x18, 0x0c, 0x06, 0xff, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0x0f, 0x18, 0x18, 0x18, 0x38, 0xf0, 0x38, 0x18, 0x18, 0x18, 0x0f},
{0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18},
{0x00, 0x00, 0xf0, 0x18, 0x18, 0x18, 0x1c, 0x0f, 0x1c, 0x18, 0x18, 0x18, 0xf0},
{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x8f, 0xf1, 0x60, 0x00, 0x00, 0x00}
};

void init_yolo(CVI_MODEL_HANDLE *model, int32_t *input_num, int32_t *output_num, CVI_TENSOR **input_tensors, CVI_TENSOR **output_tensors)
{
	int ret = 0;
	CVI_TENSOR *input;
	CVI_SHAPE input_shape;

	const char *model_file = SD_FATFS_MOUNTPOINT "/yolov5s_fused_preprocess_aligned_input.cvimodel";
	ret = CVI_NN_RegisterModel(model_file, model);
	if (ret != CVI_RC_SUCCESS)
	{
		printf("CVI_NN_RegisterModel failed, err %d\n", ret);
		CVI_NN_CleanupModel(*model);
		return;
	}
	printf("CVI_NN_RegisterModel succeeded! model file:%s\n", model_file);
	// get input output tensors
	CVI_NN_GetInputOutputTensors(*model, input_tensors, input_num, output_tensors,
								 output_num);

	input = CVI_NN_GetTensorByName(CVI_NN_DEFAULT_TENSOR, *input_tensors, *input_num);
	assert(input);

	// nchw
	input_shape = CVI_NN_TensorShape(input);
	
	printf("input shape: %d, %d\n", input_shape.dim[2], input_shape.dim[3]);
}

int BGRPacked2RBGPlanar(uint8_t *packed, uint8_t *planar, int height, int width)
{
	uint8_t *p_img = (uint8_t *)packed;
	uint8_t *p_r = planar + height * width * 2;
	uint8_t *p_g = planar + height * width;
	uint8_t *p_b = planar;

	for (int i = 0; i < height * width; i++)
	{
		*p_b++ = *p_img++;
		*p_g++ = *p_img++;
		*p_r++ = *p_img++;
	}
	return 0;
}

void BGR_resize(uint8_t *input, int width, int height, uint8_t *output, int bgr_width, int bgr_height) {
    float x_ratio = (float)width / bgr_width;
    float y_ratio = (float)height / bgr_height;
    
    for (int y = 0; y < bgr_height; y++) {
        for (int x = 0; x < bgr_width; x++) {
            int origin_x = (int)(x * x_ratio);
            int origin_y = (int)(y * y_ratio);
            
            int input_idx = (origin_y * width + origin_x) * 3;
            int output_idx = (y * bgr_width + x) * 3;
            
            memcpy(output + output_idx, input + input_idx, 3);
        }
    }
}

void run_yolo(CVI_MODEL_HANDLE model, int32_t *input_num, int32_t *output_num, CVI_TENSOR **input_tensors, CVI_TENSOR **output_tensors, VIDEO_FRAME_S stVFrame)
{
	int ret = 0;
	CVI_TENSOR *input;
	CVI_SHAPE input_shape;
	input = CVI_NN_GetTensorByName(CVI_NN_DEFAULT_TENSOR, *input_tensors, *input_num);

	input_shape = CVI_NN_TensorShape(input);
	uint8_t *ptr_packed = (uint8_t *)malloc(3 *input_shape.dim[2] * input_shape.dim[3]);
	uint8_t *ptr_planar = (uint8_t *)malloc(3 *input_shape.dim[2] * input_shape.dim[3]);
	BGR_resize((uint8_t *)stVFrame.u64PhyAddr[0], stVFrame.u32Width, stVFrame.u32Height, ptr_packed, input_shape.dim[2], input_shape.dim[3]);
	BGRPacked2RBGPlanar(ptr_packed, ptr_planar, input_shape.dim[2], input_shape.dim[3]);
	memcpy(CVI_NN_TensorPtr(input), ptr_planar, CVI_NN_TensorSize(input));
	free(ptr_packed);
	free(ptr_planar);

	ret = CVI_NN_Forward(model, *input_tensors, *input_num, *output_tensors, *output_num);
	if (ret != CVI_RC_SUCCESS)
	{
		printf("cvimodel forward failed! ret:%d\n", ret);
		CVI_NN_CleanupModel(model);
		return;
	}
}

int argmax(float *data, size_t len, size_t stride) {
    int maxIndex = 0;
    float maxValue = data[0];
    for (size_t i = 1; i < len; i++) {
        if (data[i * stride] > maxValue) {
            maxIndex = i;
            maxValue = data[i * stride];
        }
    }
    return maxIndex;
}

static float sigmoid(float x) {
    return 1.0 / (1 + expf(-x));
}

float calIou(box a, box b) {
    float area1 = a.w * a.h;
    float area2 = b.w * b.h;
    float wi = fminf((a.x + a.w / 2), (b.x + b.w / 2)) - fmaxf((a.x - a.w / 2), (b.x - b.w / 2));
    float hi = fminf((a.y + a.h / 2), (b.y + b.h / 2)) - fmaxf((a.y - a.h / 2), (b.y - b.h / 2));
    float area_i = fmaxf(wi, 0.0f) * fmaxf(hi, 0.0f);
    return area_i / (area1 + area2 - area_i);
}

int compare_det(const void *a, const void *b) {
	detection *det_a = (detection *)a;
	detection *det_b = (detection *)b;
    
    if (det_a->score < det_b->score) {
        return 1;
    } else if (det_a->score > det_b->score) {
        return -1;
    } else {
        return 0;
    }
}

void NMS(detection *dets, int *total, float thresh) {
  if (*total) {
    qsort(dets, *total, sizeof(detection), compare_det);
    int new_count = *total;
    for (int i = 0; i < *total; ++i) {
      detection *a = &dets[i];
      if (a->score == 0)
        continue;
      for (int j = i + 1; j < *total; ++j) {
        detection *b = &dets[j];
        if (dets[i].batch_idx == dets[j].batch_idx &&
            b->score != 0 && dets[i].cls == dets[j].cls &&
            calIou(a->bbox, b->bbox) > thresh) {
          b->score = 0;
          new_count--;
        }
      }
    }
    int j = 0;
    for (int i = 0; i < *total && j < new_count; ++i) {
      detection *a = &dets[i];
      if (a->score == 0)
        continue;
      dets[j] = dets[i];
      ++j;
    }
    *total = new_count;
  }
}

void draw_label(uint8_t *frame, int x1, int y1, int32_t width, int32_t height, char* label, int label_len)
{
	uint8_t *pos1, *pos2;
	uint8_t x2, y2;
	/* x1 is the same: x1 = MAX (0, (width * a->x) / bdata->i_width); */
	y1 = MAX (0, (y1 - 14));
	pos1 = &frame[(y1 * width + x1) * 3];
	for (int j = 0; j < label_len; j++) {
	unsigned int char_index = label[j];
	if (char_index < 32 || char_index >= 127) {
		/* It's not ASCII */
		char_index = '*';
	}
	char_index -= 32;
	if ((x1 + 8 * 3) > (int) width)
		break;                /* Stop drawing if it may overfill */
	pos2 = pos1;
	for (y2 = 0; y2 < 13; y2++) {
		/* 13 : character height */
		for (x2 = 0; x2 < 8; x2++) {
		/* 8: character width */
		*(pos2 + x2 * 3) = rasters[char_index][13-y2] & (1 << (7 - x2)) ?
			PIXEL_VALUE : *(pos2 + x2 * 3);
		}
		pos2 += width * 3;
	}
	x1 += 9 * 3;
	pos1 += 9 * 3;              /* charater width + 1px */
	}
}

void draw(VIDEO_FRAME_S stVFrame, detection *dets, int32_t dets_num, uint64_t start_time)
{
	uint8_t *frame = (uint8_t *)stVFrame.u64PhyAddr[0];
	int32_t color = 3;
  	int32_t width = stVFrame.u32Width;
  	int32_t height = stVFrame.u32Height;

	for (uint8_t i = 0; i < dets_num; i++) {
		int x1, x2, y1, y2;         /* Box positions on the output surface */
		int j;
		uint8_t *pos1, *pos2;
		/* 1. Draw Boxes */
		x1 =  dets[i].bbox.x > dets[i].bbox.w / 2 ? dets[i].bbox.x - dets[i].bbox.w / 2 : 0;
		x2 =  fminf (width - 1,dets[i].bbox.x + dets[i].bbox.w / 2);
        y1 =  dets[i].bbox.y > dets[i].bbox.h / 2 ? dets[i].bbox.y - dets[i].bbox.h / 2 : 0;
        y2 =  fminf (height - 1,dets[i].bbox.y + dets[i].bbox.h / 2);
		/* 1-1. Horizontal */
		pos1 = &frame[(y1 * width + x1) * color];
		pos2 = &frame[(y2 * width + x1) * color];
		for (j = x1; j <= x2; j++) {
		*(pos1 + 2) = PIXEL_VALUE;
		*(pos2 + 2) = PIXEL_VALUE;
		pos1 += color;
		pos2 += color;
		}

		/* 1-2. Vertical */
		pos1 = &frame[((y1 + 1) * width + x1) * color];
		pos2 = &frame[((y1 + 1) * width + x2) * color];
		for (j = y1 + 1; j < y2; j++) {
		*(pos1 + 2) = PIXEL_VALUE;
		*(pos2 + 2) = PIXEL_VALUE;
		pos1 += width * color;
		pos2 += width * color;
		}

		/* 2. Write Labels + tracking ID */
		char label[20];
		int label_len;
		label_len = snprintf(label, sizeof(label), "%s %.2f", coco_names[dets[i].cls], dets[i].score);
		draw_label(frame, x1, y1, width, height, label, label_len);

  	}
	/* 3. Draw FPS */
	char fps[20];
	int fps_len;
	fps_len = snprintf(fps, sizeof(fps), "%.2f", 1000.0 / (float)(aos_now_ms() - start_time));
	draw_label(frame, 0, 0, width, height, fps, fps_len);
}

void draw_res(VIDEO_FRAME_S stVFrame, int32_t input_num, int32_t output_num, CVI_TENSOR *input_tensors, CVI_TENSOR *output_tensors, uint64_t start_time)
{
	CVI_SHAPE output_shape;

	int bbox_len = 85; // classes num + 5
	int classes_num = 80;
	float conf_thresh = 0.5;
	float iou_thresh = 0.5;
	int det_num = 0;
	detection *dets = (detection *)malloc(sizeof(detection) * 5000);

	CVI_TENSOR *input;
	CVI_SHAPE input_shape;
	float x_ratio;
	float y_ratio;
	
	input = CVI_NN_GetTensorByName(CVI_NN_DEFAULT_TENSOR, input_tensors, input_num);
	input_shape = CVI_NN_TensorShape(input);

	x_ratio = (float)stVFrame.u32Width / input_shape.dim[2];
	y_ratio = (float)stVFrame.u32Height / input_shape.dim[3];

	for (int j = 0; j < output_num; j++)
    {
		// nchw
		output_shape = CVI_NN_TensorShape(&output_tensors[j]);

		CVI_TENSOR *output_tensor = &output_tensors[j];
		float *output_ptr = (float *)CVI_NN_TensorPtr(output_tensor);
		int w_stride = 1;
		int h_stride = output_shape.dim[3] * w_stride; //80
		int o_stride = output_shape.dim[2] * h_stride; //80 * 80 = 6400
		int a_stride = bbox_len * o_stride; 		// 85 * 80 * 80 = 57600
		float down_stride = 640 / output_shape.dim[3]; // 640 / 80 = 8
		for (int a = 0; a < 3; ++a)
		{
			for (int i = 0; i < output_shape.dim[3] * output_shape.dim[2]; ++i)
			{
				int col = i % output_shape.dim[3];
				int row = i / output_shape.dim[3];
				float *obj = output_ptr + a * a_stride + row * h_stride +
								col * w_stride + 4 * o_stride;
				float objectness = sigmoid(obj[0]);
				if (objectness <= conf_thresh)
				{
					continue;
				}
				float *scores = obj + 1 * o_stride;
				int category = argmax(scores, classes_num, o_stride);
				objectness *= sigmoid(scores[category * o_stride]);

				if (objectness <= conf_thresh)
				{
					continue;
				}
				// printf("objectness:%f, score:%f\n", sigmoid(obj[0]), sigmoid(scores[category]));

				float x = *(obj - 4 * o_stride);
				float y = *(obj - 3 * o_stride);
				float w = *(obj - 2 * o_stride);
				float h = *(obj - 1 * o_stride);
				detection det_obj;
				det_obj.score = objectness;
				det_obj.cls = category;
				det_obj.batch_idx = 1;

				det_obj.bbox.x = (sigmoid(x) * 2 - 0.5 + col) * down_stride * x_ratio;
				det_obj.bbox.y = (sigmoid(y) * 2 - 0.5 + row) * down_stride * y_ratio;
				det_obj.bbox.w =
					pow(sigmoid(w) * 2, 2) * anchors_[j][a][0] * x_ratio;
				det_obj.bbox.h =
					pow(sigmoid(h) * 2, 2) * anchors_[j][a][1] * y_ratio;
				dets[det_num] = det_obj;
				++det_num;
			}
		}
	}
	// correct box with origin image size
	if(det_num > 0)
	{
		printf("raw detection num: %d\n", det_num);
		NMS(dets, &det_num, iou_thresh);
		//correctYoloBoxes(dets, det_num, height, width, height, width);
		printf("get detection num: %d\n", det_num);

		// print bbox
		for (int i = 0; i < det_num; i++) {
		printf("obj %d: [%f %f %f %f] score:%f cls:%s \n", i, dets[i].bbox.x,
				dets[i].bbox.y, dets[i].bbox.w, dets[i].bbox.h, dets[i].score,
				coco_names[dets[i].cls]);
		}

		printf("------\n");
		printf("%d objects are detected\n", det_num);
		printf("usd time: %lld ms\n", (aos_now_ms() - start_time));
		printf("------\n");
	}
	draw(stVFrame, dets, det_num, start_time);
	free(dets);
}

void BGR2YUV(uint8_t *yuv2, uint8_t *bgr, uint32_t width, uint32_t height)
{
	uint32_t yuv2_index = 0;
	uint32_t bgr_index = 0;

	for (uint32_t y = 0; y < height; ++y)
	{
		for (uint32_t x = 0; x < width; x += 2)
		{
			uint8_t b1 = bgr[bgr_index++];
			uint8_t g1 = bgr[bgr_index++];
			uint8_t r1 = bgr[bgr_index++];
			uint8_t b2 = bgr[bgr_index++];
			uint8_t g2 = bgr[bgr_index++];
			uint8_t r2 = bgr[bgr_index++];

			uint8_t y1 = (uint8_t)(0.299 * r1 + 0.587 * g1 + 0.114 * b1);
			uint8_t u = (uint8_t)(-0.169 * r1 - 0.331 * g1 + 0.5 * b1 + 128);
			uint8_t y2 = (uint8_t)(0.299 * r2 + 0.587 * g2 + 0.114 * b2);
			uint8_t v = (uint8_t)(0.5 * r2 - 0.419 * g2 - 0.081 * b2 + 128);

			yuv2[yuv2_index++] = y1;
			yuv2[yuv2_index++] = u;
			yuv2[yuv2_index++] = y2;
			yuv2[yuv2_index++] = v;
		}
		yuv2_index += width;
	}
}
